$a := [-90, 90, 0]
$d := [1, 1, 1]

whenever ($a[0] || $d[0]) {
	spat source 1 aed ($a[0]) 0 ($d[0])
}
whenever ($a[1] || $d[1]) {
	spat source 2 aed ($a[1]) 0 ($d[1])
}
whenever ($a[2] || $d[2]) {
	spat source 3 aed ($a[2]) 0 ($d[2])
}


// dynamic spat processes

@proc_def ::spat_repelAttacks($source) {
	@local $start_d
	$start_d := $d[($source-1)]
	repel $source $start_d
;	whenever ($energy) {
;		$d[($source-1)] := $start_d * ($energy*3 + 0.5)
;		$d := $d 	; trigger update
;	}
}

@proc_def ::spat_circular($source, $dir) {
	@local $start_a
	loop circular 0.5 {
		$start_a := $a[($source-1)]
		$a[($source-1)] := $start_a + $dir * (1.1 - $periodicity)
		$a := $a
	}
}

@proc_def ::spat_teleport($source) {
	@local $start_a, $start_d, $rand
	$start_d := $d[($source-1)]
	whenever ($BEAT_POS) { // for each new event, teleport
		if (@rand_int(100) < 33) {
			$start_a := $a[($source-1)]
			$rand := @rand_int(90) * (@rand_int(2) * 2 - 1)
			curve MOVE @Grain := 0.05s, @Action := {
				$a[($source-1)] := $x1; $a[($source-1)] + @rand_int(360)
				$a := $a
			}
			{ $x1 {
					{ $start_a }
				1	{ ($start_a + $rand) }
			} }			
		}
	}
}

@proc_def ::spat_radial($source) {
	@local $start_a
	$start_a := $a[($source-1)]
	whenever ($periodicity) {
		spat source $source azim ($start_a + ($periodicity - 0.5) * 20)
	}
}

@proc_def ::spat_spray($source, $a, $d) {

}

@proc_def ::spat_goto($source, $to_a, $to_d, $time) {
	@local $start_a, $start_d
	$start_a := $a[($source-1)]
	$start_d := $d[($source-1)]
	curve GOTO @Grain := 0.05s, @Action := {
		$a[($source-1)] := $x1
		$d[($source-1)] := $x2
		$a := $a
	}
	{ $x1, $x2 {
		{$start_a, $start_d}
		$time {$to_a, $to_d}
	}}	
}